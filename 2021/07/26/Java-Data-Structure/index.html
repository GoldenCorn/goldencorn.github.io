<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"goldencorn.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="Sparse Array    稀疏数组稀疏数组的应用场景当使用二维数组记录一个棋盘时，假如当前棋盘上的棋子很少，会导致很多值是默认值 0 ，因此记录了很多没有意义的数据。此时就可以使用稀疏数组来对二维数组进行压缩。 稀疏数组的处理方法是：  记录数组有几行几列，有多少个不同的值； 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Data Structure">
<meta property="og:url" content="https://goldencorn.github.io/2021/07/26/Java-Data-Structure/index.html">
<meta property="og:site_name" content="神烦骑士的秘密基地">
<meta property="og:description" content="Sparse Array    稀疏数组稀疏数组的应用场景当使用二维数组记录一个棋盘时，假如当前棋盘上的棋子很少，会导致很多值是默认值 0 ，因此记录了很多没有意义的数据。此时就可以使用稀疏数组来对二维数组进行压缩。 稀疏数组的处理方法是：  记录数组有几行几列，有多少个不同的值； 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-07-26T08:19:53.000Z">
<meta property="article:modified_time" content="2021-08-05T08:18:53.520Z">
<meta property="article:author" content="神烦骑士">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://goldencorn.github.io/2021/07/26/Java-Data-Structure/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://goldencorn.github.io/2021/07/26/Java-Data-Structure/","path":"2021/07/26/Java-Data-Structure/","title":"Java Data Structure"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java Data Structure | 神烦骑士的秘密基地</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">神烦骑士的秘密基地</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sparse-Array-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">Sparse Array    稀疏数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">稀疏数组的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">1.2.</span> <span class="nav-text">二维数组转稀疏数组的思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.</span> <span class="nav-text">稀疏数组转二维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">Queue    队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="nav-number">2.1.</span> <span class="nav-text">数组模拟队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="nav-number">2.2.</span> <span class="nav-text">数组模拟环形队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-number">2.2.1.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">2.2.2.</span> <span class="nav-text">代码优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linked-List-%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">Linked List    链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.1.</span> <span class="nav-text">单向链表的应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-number">3.1.1.</span> <span class="nav-text">方法一思路分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">方法一代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-number">3.1.3.</span> <span class="nav-text">方法二思路分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.4.</span> <span class="nav-text">方法二代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">3.1.5.</span> <span class="nav-text">节点的修改</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">3.1.6.</span> <span class="nav-text">节点的删除</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">单链表常见面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B1-%E6%B1%82%E5%8D%95%E9%93%BE%E8%A1%A8%E7%A7%8D%E6%9C%89%E6%95%88%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">例1  求单链表种有效节点的个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B2-%E6%9F%A5%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%90%E6%96%B0%E6%B5%AA%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91"><span class="nav-number">3.2.2.</span> <span class="nav-text">例2  查找单链表中的倒数第 k 个节点【新浪面试题】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B3-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC%E3%80%90%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91"><span class="nav-number">3.2.3.</span> <span class="nav-text">例3  单链表的反转【腾讯面试题】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B4-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%90%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91"><span class="nav-number">3.2.4.</span> <span class="nav-text">例4  从尾到头打印单链表【百度面试题】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B5-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%90%88%E5%B9%B6%E4%B9%8B%E5%90%8E%E7%9A%84%E9%93%BE%E8%A1%A8%E4%BE%9D%E7%84%B6%E6%9C%89%E5%BA%8F"><span class="nav-number">3.2.5.</span> <span class="nav-text">例5  合并两个有序单链表，合并之后的链表依然有序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.3.</span> <span class="nav-text">双向链表的应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">双向链表代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.4.</span> <span class="nav-text">单向环形链表应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack-%E6%A0%88"><span class="nav-number">4.</span> <span class="nav-text">Stack    栈</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="神烦骑士"
      src="https://pic.imgdb.cn/item/60b8adc28355f7f71805a59b.jpg">
  <p class="site-author-name" itemprop="name">神烦骑士</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/GoldenCorn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GoldenCorn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://goldencorn.github.io/2021/07/26/Java-Data-Structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic.imgdb.cn/item/60b8adc28355f7f71805a59b.jpg">
      <meta itemprop="name" content="神烦骑士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神烦骑士的秘密基地">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java Data Structure
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-26 16:19:53" itemprop="dateCreated datePublished" datetime="2021-07-26T16:19:53+08:00">2021-07-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-05 16:18:53" itemprop="dateModified" datetime="2021-08-05T16:18:53+08:00">2021-08-05</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Data-Structure/" itemprop="url" rel="index"><span itemprop="name">Data Structure</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/07/26/Java-Data-Structure/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/07/26/Java-Data-Structure/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="Sparse-Array-稀疏数组"><a href="#Sparse-Array-稀疏数组" class="headerlink" title="Sparse Array    稀疏数组"></a>Sparse Array    稀疏数组</h3><h4 id="稀疏数组的应用场景"><a href="#稀疏数组的应用场景" class="headerlink" title="稀疏数组的应用场景"></a>稀疏数组的应用场景</h4><p>当使用二维数组记录一个棋盘时，假如当前棋盘上的棋子很少，会导致很多值是默认值 0 ，因此记录了很多没有意义的数据。此时就可以使用稀疏数组来对二维数组进行压缩。</p>
<p>稀疏数组的处理方法是：</p>
<ol>
<li>记录数组有几行几列，有多少个不同的值；</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。</li>
</ol>
<h4 id="二维数组转稀疏数组的思路"><a href="#二维数组转稀疏数组的思路" class="headerlink" title="二维数组转稀疏数组的思路"></a>二维数组转稀疏数组的思路</h4><ol>
<li>遍历原始的二维数组，得到有效数据的个数 <code>sum</code> ；</li>
<li>根据 sum 就可以创建稀疏数组 <code>sparseArr int[sum + 1][3]</code> ；</li>
<li>将二维数组的有效数据存入稀疏数组。</li>
</ol>
<h4 id="稀疏数组转二维数组"><a href="#稀疏数组转二维数组" class="headerlink" title="稀疏数组转二维数组"></a>稀疏数组转二维数组</h4><ol>
<li>先读取稀疏数组第一行获取二维数组的行数和列数以及数据个数，创建原始的二维数组；</li>
<li>再读取稀疏数组的后几行数据，并赋给原始的二维数组即可。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.star.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] chessArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始二维数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转为稀疏数组，先得到非0数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="number">0</span>)</span><br><span class="line">                    sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArray = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">0</span>] = chessArray[<span class="number">0</span>].length;</span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">1</span>] = chessArray.length;</span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessArray[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArray[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArray[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArray[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArray[count][<span class="number">2</span>] = chessArray[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;转换得到的稀疏数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : sparseArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将稀疏数组复原成二维数组</span></span><br><span class="line">        <span class="keyword">int</span> rows = sparseArray[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cols = sparseArray[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//int noneZero = sparseArray[0][2];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] newChessArray = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> row = sparseArray[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col = sparseArray[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> data = sparseArray[i][<span class="number">2</span>];</span><br><span class="line">            newChessArray[row][col] = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;复原后的二维数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : newChessArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue    队列"></a>Queue    队列</h3><p>队列是一个有序列表，遵循先入先出的原则，可以用数组或链表来实现。</p>
<h4 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.star.queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组实现队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//指向头的指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//指向队尾的指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;     <span class="comment">//队列为空时，指向队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;      <span class="comment">//指向队尾的数据的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先让rear后移</span></span><br><span class="line">        rear++;</span><br><span class="line">        array[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先将front后移，返回当前指向的数据</span></span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> array[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front + <span class="number">1</span>; i &lt;= rear; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示头部数据，不取出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的问题是数组只能使用一次，因为当两个指针都移动到容量尾端时，没有办法再向数组中添加数据。因此，需要对数组进行优化，将队列用取模的方式优化成环形队列。</p>
<h4 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h4><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><ol>
<li>对 <code>front</code> 变量的含义做调整：由指向第一个元素的前一个位置变为指向第一个元素的位置，初始值为 0 ；</li>
<li>对 <code>rear</code> 变量的含义做调整：由指向最后一个元素的位置变为指向最后一个元素的后一个位置，初始值为 0 ，因为希望空出一个空间作为约定；</li>
<li>当队列满时，条件是 <code>(rear + 1) % maxSize == front</code> ，此时的 <code>maxSize</code> 为实例化时的实参 + 1；</li>
<li>当队列空时，条件是 <code>rear == front</code> ；</li>
<li>队列中当前有效的数据的个数是 <code>(rear + maxSize - front) % maxSize</code> 。</li>
</ol>
<h5 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.star.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//指向第一个元素的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//指向最后一个元素的后一个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize + <span class="number">1</span>;     <span class="comment">//预留一个位置，如果不预留就不需要加 1</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先将数据入队</span></span><br><span class="line">        array[rear] = n;</span><br><span class="line">        <span class="comment">//将 rear 后移</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">        printQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先将数据保存到临时变量，改变了 front 的值后再弹出</span></span><br><span class="line">        <span class="keyword">var</span> temp = array[front];</span><br><span class="line">        <span class="comment">//将 front 后移</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, array[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求当前队列中有效数据的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示头部数据，不取出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组如果不预留最后一位的话，当数据出队 <code>front</code> 指针向前移动，并继续将数据入队时，会出现队列已满的错误，因为只有当 <code>(rear + 1) % maxSize != front</code> 时才表示队列还有位置。</p>
<h3 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List    链表"></a>Linked List    链表</h3><p>链表的每个节点包含 <code>data</code> 域，用来存放数据，还有一个 <code>next</code> 域，指向下一个节点的地址。链表的各个节点在内存中不一定是连续存储的。</p>
<p>链表分为带头节点的链表和不带头节点的链表，根据实际的需求来确定。</p>
<h4 id="单向链表的应用实例"><a href="#单向链表的应用实例" class="headerlink" title="单向链表的应用实例"></a>单向链表的应用实例</h4><p>使用带头节点的单链表来完成水浒英雄排行榜管理。</p>
<ol>
<li>完成对人物的增删改查操作；</li>
<li>第一种方法：在添加人物时，直接添加到链表末尾，不考虑顺序；</li>
<li>第二种方法：在添加人物时，根据排名插入到指定位置（如果排名重复，则添加失败）；</li>
</ol>
<h5 id="方法一思路分析"><a href="#方法一思路分析" class="headerlink" title="方法一思路分析"></a>方法一思路分析</h5><ol>
<li>先创建一个 <code>head</code> 节点，不存放数据，只是表示链表的头部， <code>next</code> 指针指向第一个节点的位置；</li>
<li>每添加一个节点，就直接加到链表的末尾；</li>
<li>遍历时，通过一个辅助指针帮助遍历整个链表。</li>
</ol>
<h5 id="方法一代码实现"><a href="#方法一代码实现" class="headerlink" title="方法一代码实现"></a>方法一代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.star.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>));</span><br><span class="line"></span><br><span class="line">        list.printList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> rank;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;   <span class="comment">//下一节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> rank, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rank = rank;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写 ToString 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;rank=&quot;</span> + rank +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个头节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为 head 节点不能动，因此需要辅助指针</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出循环表示当前节点是最后一个节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="方法二思路分析"><a href="#方法二思路分析" class="headerlink" title="方法二思路分析"></a>方法二思路分析</h5><ol>
<li>根据排名首先找到需要新添加的节点对应的位置，通过辅助指针遍历链表来确定；</li>
<li>新的节点的 <code>next</code> 域就应该等于辅助指针的 <code>next</code> 域；</li>
<li>将辅助指针的 <code>next</code> 域指向新的节点的位置。</li>
</ol>
<h5 id="方法二代码实现"><a href="#方法二代码实现" class="headerlink" title="方法二代码实现"></a>方法二代码实现</h5><p>只需要添加一个 <code>addByRank()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByRank</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    <span class="comment">//需要新添加的节点排名是否已存在</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果下一个节点的排名大于新的节点的排名，说明当前位置就是插入点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next.rank &gt; node.rank) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.rank == node.rank) &#123;</span><br><span class="line">            <span class="comment">//下一节点的排名与新的节点排名相等，说明已存在</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指针后移</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历结束</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;记录已存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将节点插入链表</span></span><br><span class="line">    node.next = temp.next;</span><br><span class="line">    temp.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="节点的修改"><a href="#节点的修改" class="headerlink" title="节点的修改"></a>节点的修改</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据新节点的排名来修改对应节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;   <span class="comment">//是否找到节点</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.rank == newNode.rank) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找到</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        temp.name = newNode.name;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到该节点&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h5><ol>
<li>先找到待删除节点的前一个节点的位置 <code>prev</code> ；</li>
<li>使 <code>prev.next = prev.next.next</code> ；</li>
<li>被删除的节点没有被引用，将被垃圾回收机制回收。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按排名删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">    HeroNode prev = head;</span><br><span class="line">    <span class="comment">//是否找到待删除节点</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev.next.rank == rank) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历结束，如果找到该节点</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        prev.next = prev.next.next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到待删除节点&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="单链表常见面试题"><a href="#单链表常见面试题" class="headerlink" title="单链表常见面试题"></a>单链表常见面试题</h4><h5 id="例1-求单链表种有效节点的个数"><a href="#例1-求单链表种有效节点的个数" class="headerlink" title="例1  求单链表种有效节点的个数"></a>例1  求单链表种有效节点的个数</h5><p>如果带头节点的链表，不统计头节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取某个链表的有效节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 有效的节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="例2-查找单链表中的倒数第-k-个节点【新浪面试题】"><a href="#例2-查找单链表中的倒数第-k-个节点【新浪面试题】" class="headerlink" title="例2  查找单链表中的倒数第 k 个节点【新浪面试题】"></a>例2  查找单链表中的倒数第 k 个节点【新浪面试题】</h5><p>思路：</p>
<ol>
<li>编写一个方法，接收 <code>head</code> 节点和 <code>index</code> 节点， <code>index</code> 即表示倒数第 k 个节点；</li>
<li>先得到链表中的节点个数；</li>
<li>得到节点个数 <code>length</code> 后，再遍历到第 <code>length - index</code> 个即为倒数第 k 个节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找单链表中的倒数第 k 个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 倒数第 index 个节点的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果节点存在，返回倒数第 index 个节点；否则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//得到链表节点个数</span></span><br><span class="line">    <span class="keyword">int</span> length = getLength(head);</span><br><span class="line">    <span class="comment">//先对 index 进行校验</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HeroNode cur = head.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - index; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="例3-单链表的反转【腾讯面试题】"><a href="#例3-单链表的反转【腾讯面试题】" class="headerlink" title="例3  单链表的反转【腾讯面试题】"></a>例3  单链表的反转【腾讯面试题】</h5><p>思路：</p>
<ol>
<li>先定义一个新的头节点，作为反转后的链表的头节点；</li>
<li>遍历原链表，每遍历一个节点，就将其取出并放在新的链表的前端；</li>
<li>将原链表的头节点的下一节点指向新链表的头节点的下一节点（使链表能用原来的头节点访问）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将单链表反转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前链表为空，或只有一个节点则无需反转</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//辅助指针</span></span><br><span class="line">    HeroNode cur = head.next;</span><br><span class="line">    <span class="comment">//指向当前节点的下一个节点</span></span><br><span class="line">    HeroNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//新的头节点</span></span><br><span class="line">    HeroNode newHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        <span class="comment">//将节点放到新链表最前端</span></span><br><span class="line">        cur.next = newHead.next;</span><br><span class="line">        newHead.next = cur;</span><br><span class="line">        <span class="comment">//节点后移</span></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将原链表的头节点下一节点指向新链表的第一个节点</span></span><br><span class="line">    head.next = newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="例4-从尾到头打印单链表【百度面试题】"><a href="#例4-从尾到头打印单链表【百度面试题】" class="headerlink" title="例4  从尾到头打印单链表【百度面试题】"></a>例4  从尾到头打印单链表【百度面试题】</h5><p>思路：</p>
<ol>
<li>方式一：先将链表反转，然后遍历。这样的问题是会破坏原链表的结构，<strong>不建议</strong>。</li>
<li>方式二：利用栈将各个节点压入，然后利用先入后出的特点实现逆序打印。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈实现逆序打印</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HeroNode cur = head.next;</span><br><span class="line">    <span class="comment">//将链表所有节点压入栈</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//边弹出边打印</span></span><br><span class="line">    <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="例5-合并两个有序单链表，合并之后的链表依然有序"><a href="#例5-合并两个有序单链表，合并之后的链表依然有序" class="headerlink" title="例5  合并两个有序单链表，合并之后的链表依然有序"></a>例5  合并两个有序单链表，合并之后的链表依然有序</h5><p>思路：</p>
<ol>
<li>新建一个头节点作为合并链表的头节点；</li>
<li>分别遍历两个单链表，同时比较当前两个节点的大小，将更小的那个加入新的链表；</li>
<li>当其中一个链表提前遍历完时，直接将另一个链表的后续节点加入新链表。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据排名合并两个有序单链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head1  第一个链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head2  第二个链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(HeroNode head1, HeroNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//假如不能使用之前写好的 add 方法</span></span><br><span class="line">    HeroNode newHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//新的链表的指针</span></span><br><span class="line">    HeroNode ptr = newHead;</span><br><span class="line">    <span class="comment">//第一个链表的辅助指针</span></span><br><span class="line">    HeroNode cur1 = head1.next;</span><br><span class="line">    HeroNode next1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//第二个链表的辅助指针</span></span><br><span class="line">    HeroNode cur2 = head2.next;</span><br><span class="line">    HeroNode next2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur1.rank &lt; cur2.rank) &#123;</span><br><span class="line">            <span class="comment">//暂存下一个节点</span></span><br><span class="line">            next1 = cur1.next;</span><br><span class="line">            <span class="comment">//使新链表当前节点的下一个节点指向新的节点</span></span><br><span class="line">            ptr.next = cur1;</span><br><span class="line">            <span class="comment">//新链表指针后移</span></span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">            <span class="comment">//第一个链表指针后移</span></span><br><span class="line">            cur1 = next1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur1.rank &gt; cur2.rank) &#123;</span><br><span class="line">            next2 = cur2.next;</span><br><span class="line">            ptr.next = cur2;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">            cur2 = next2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有一个链表已经遍历完，另一个没有遍历完</span></span><br><span class="line">    <span class="keyword">if</span> (cur1 == <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//直接将第二个链表剩余的节点加入</span></span><br><span class="line">        ptr.next = cur2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur2 == <span class="keyword">null</span> &amp;&amp; cur1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ptr.next = cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假如要求要根据第一个链表的头节点打印</span></span><br><span class="line">    head1.next = newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双向链表的应用实例"><a href="#双向链表的应用实例" class="headerlink" title="双向链表的应用实例"></a>双向链表的应用实例</h4><p>单向链表只能一个方向查找，不能自我删除，需要依靠辅助指针；而双向链表可以向前或向后查找，并且可以自我删除。</p>
<p>双链表遍历的方式和单链表一样，只是可以向前或向后查找；</p>
<p>添加元素时是默认添加到双链表的最后，先找到双链表最后的节点，使最后节点的 <code>next</code> 指针指向新节点，使新节点的 <code>prev</code> 指针指向当前最后的节点；</p>
<p>修改的思路和单链表一样；</p>
<p>删除元素时，可以直接找到待删除的元素，实现自我删除。</p>
<h5 id="双向链表代码实现"><a href="#双向链表代码实现" class="headerlink" title="双向链表代码实现"></a>双向链表代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleHeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> rank;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> DoubleHeroNode next;   <span class="comment">//下一节点</span></span><br><span class="line">    <span class="keyword">public</span> DoubleHeroNode prev;   <span class="comment">//前一节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleHeroNode</span><span class="params">(<span class="keyword">int</span> rank, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rank = rank;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写 ToString 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;rank=&quot;</span> + rank +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListDouble</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个头节点</span></span><br><span class="line">    <span class="keyword">private</span> DoubleHeroNode head = <span class="keyword">new</span> DoubleHeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DoubleHeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到双向链表末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(DoubleHeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为 head 节点不能动，因此需要辅助指针</span></span><br><span class="line">        DoubleHeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出循环表示当前节点是最后一个节点</span></span><br><span class="line">        <span class="comment">//最后节点 next 指针指向新节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">        <span class="comment">//新节点 prev 指针指向最后节点</span></span><br><span class="line">        node.prev = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照排名添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByRank</span><span class="params">(DoubleHeroNode node)</span> </span>&#123;</span><br><span class="line">        DoubleHeroNode temp = head;</span><br><span class="line">        <span class="comment">//是否有重复记录</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点的下一节点排名大于待添加节点排名，就插入当前节点位置</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.rank &gt; node.rank) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.rank == node.rank) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;记录已存在，无法重复插入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入节点</span></span><br><span class="line">        node.prev = temp;</span><br><span class="line">        node.next = temp.next;</span><br><span class="line">        <span class="comment">//当前节点的下一节点不为空时才给下一个节点重置 prev 指针</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next.prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据新节点的排名来修改对应节点，和单链表步骤一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(DoubleHeroNode newNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoubleHeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;   <span class="comment">//是否找到节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.rank == newNode.rank) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newNode.name;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有找到该节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按排名删除，直接找到待删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoubleHeroNode cur = head.next;</span><br><span class="line">        <span class="comment">//是否找到待删除节点</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.rank == rank) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结束，如果找到该节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            cur.prev.next = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="keyword">null</span>)</span><br><span class="line">                cur.next.prev = cur.prev;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有找到待删除节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DoubleHeroNode temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="单向环形链表应用场景"><a href="#单向环形链表应用场景" class="headerlink" title="单向环形链表应用场景"></a>单向环形链表应用场景</h4><p>Joseph 问题：设编号为 1…n 的 n 个人围坐一圈，约定编号为 k (1 &lt;= k &lt;= n) 的人从 1 开始报数，数到 m 的人出列，他的下一位又从 1 开始报数，数到 m 的人又出列，以此类推，直到所有人都出列为止，由此产生一个出队编号的序列。</p>
<p>思路：</p>
<p>先创建一个不带头节点的有 n 个节点的单向循环链表，然后从 k 节点起从 1 开始计数，计到 m 时，对应节点从链表中删除，然后再从被删除节点的下一个节点开始重新从 1 计数，直到最后一个节点从链表中删除。</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>构建一个单向环形链表的思路：</p>
<ol>
<li>先创建第一个节点，并设置标识 first ，然后让它的 next 指针指向自己，形成环形；</li>
<li>每创建一个新节点，就把该节点的 next 指针指向第一个节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向环形链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化第一个节点</span></span><br><span class="line">    <span class="keyword">private</span> ListNode first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点，构成环形链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 总的人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;人数不能小于1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从 1 开始创建 count 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            <span class="comment">//按照编号创建节点</span></span><br><span class="line">            <span class="keyword">var</span> node = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            <span class="comment">//如果是第一个节点，还需要赋给 first 指针</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = node;</span><br><span class="line">                <span class="comment">//使指针指向自己构成环形</span></span><br><span class="line">                first.setNext(first);</span><br><span class="line">                <span class="comment">//设置 cur 指针的初始位置</span></span><br><span class="line">                cur = first;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是第一个节点</span></span><br><span class="line">            cur.setNext(node);</span><br><span class="line">            node.setNext(first);</span><br><span class="line">            <span class="comment">//移动辅助指针</span></span><br><span class="line">            cur = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">var</span> cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, cur.getNum());</span><br><span class="line">            <span class="comment">//如果当前节点的下一个节点是 first ，则表示遍历完毕</span></span><br><span class="line">            <span class="keyword">if</span> (cur.getNext() == first)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//移动指针</span></span><br><span class="line">            cur = cur.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;    <span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> ListNode next;  <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>出队的思路：</p>
<ol>
<li>需要一个辅助指针，事先指向环形链表的最后一个节点；</li>
<li>将 <code>first</code> 指针根据 k 值移动到设置的起始位置；</li>
<li>报数时，让辅助指针和 <code>first</code> 指针同时移动 m - 1 次；</li>
<li>这时可以将 <code>first</code> 指针指向的节点出队，先将 <code>first</code> 指针移动到下一个节点处，再让辅助指针指向节点的 <code>next</code> 指针指向 <code>first</code> 指针所处位置即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户输入，生成出队顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startNum 表示从第几个节点开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count 移动多少次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 共有多少人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popNodes</span><span class="params">(<span class="keyword">int</span> startNum, <span class="keyword">int</span> count, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验参数是否符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (startNum &lt; <span class="number">1</span> || startNum &gt; nums) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;参数有误，请重新输入&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//辅助指针，先找到最后一个节点</span></span><br><span class="line">    ListNode helper = first;</span><br><span class="line">    <span class="keyword">while</span> (helper.getNext() != first) &#123;</span><br><span class="line">        helper = helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//报数前指针先移动到起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.getNext();</span><br><span class="line">        helper = helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始出队，如果 helper == first 说明当前队中只剩一人</span></span><br><span class="line">    <span class="keyword">while</span> (helper != first) &#123;</span><br><span class="line">        <span class="comment">//两个指针同时移动 count - 1 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移动完毕，此时 first 指针指向的节点即为要出队的节点</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;编号%d出队\n&quot;</span>, first.getNum());</span><br><span class="line">        first = first.getNext();</span><br><span class="line">        helper.setNext(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环完毕，只剩下最后一个节点</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;最后出队的是编号%d\n&quot;</span>, first.getNum());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack    栈"></a>Stack    栈</h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" rel="prev" title="大数据平台开发技术">
                  <i class="fa fa-chevron-left"></i> 大数据平台开发技术
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/12/29/Java-Basics/" rel="next" title="Java Basics">
                  Java Basics <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">神烦骑士</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"default","js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.11.0/dist/mermaid.min.js","integrity":"sha256-sVAx+v/Q7v0Q2xm5vN7h5ccSna6gaLREhG9sF8pKT6I="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"goldencorn","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
