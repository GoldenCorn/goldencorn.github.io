<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"goldencorn.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="无语了，刷过的题忘得好快，包括解法全部忘光光。稍微记录一下。    2021.6.11    124    二叉树中的最大路径和    难度：Hard 题目描述： 124. 二叉树中的最大路径和    思路： 利用二叉树的后序遍历计算不同子树的路径和，即左节点的值加上右节点的值加上该节点的值。每次计算都比较一次最大值，最后得到的最大值即为最大路径和。    细节：  递归的基线条件：root &#x3D;&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题记录 —— 树">
<meta property="og:url" content="https://goldencorn.github.io/2021/06/11/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E2%80%94%E2%80%94-%E6%A0%91/index.html">
<meta property="og:site_name" content="神烦骑士的秘密基地">
<meta property="og:description" content="无语了，刷过的题忘得好快，包括解法全部忘光光。稍微记录一下。    2021.6.11    124    二叉树中的最大路径和    难度：Hard 题目描述： 124. 二叉树中的最大路径和    思路： 利用二叉树的后序遍历计算不同子树的路径和，即左节点的值加上右节点的值加上该节点的值。每次计算都比较一次最大值，最后得到的最大值即为最大路径和。    细节：  递归的基线条件：root &#x3D;&#x3D;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-06-11T13:51:20.000Z">
<meta property="article:modified_time" content="2021-06-25T07:00:54.037Z">
<meta property="article:author" content="神烦骑士">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://goldencorn.github.io/2021/06/11/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E2%80%94%E2%80%94-%E6%A0%91/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://goldencorn.github.io/2021/06/11/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E2%80%94%E2%80%94-%E6%A0%91/","path":"2021/06/11/LeetCode刷题记录-——-树/","title":"LeetCode刷题记录 —— 树"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode刷题记录 —— 树 | 神烦骑士的秘密基地</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">神烦骑士的秘密基地</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-11"><span class="nav-number">1.</span> <span class="nav-text">2021.6.11</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-12"><span class="nav-number">2.</span> <span class="nav-text">2021.6.12</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-13"><span class="nav-number">3.</span> <span class="nav-text">2021.6.13</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-14"><span class="nav-number">4.</span> <span class="nav-text">2021.6.14</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-16"><span class="nav-number">5.</span> <span class="nav-text">2021.6.16</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-17"><span class="nav-number">6.</span> <span class="nav-text">2021.6.17</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-18"><span class="nav-number">7.</span> <span class="nav-text">2021.6.18</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-19"><span class="nav-number">8.</span> <span class="nav-text">2021.6.19</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-20"><span class="nav-number">9.</span> <span class="nav-text">2021.6.20</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="神烦骑士"
      src="https://pic.imgdb.cn/item/60b8adc28355f7f71805a59b.jpg">
  <p class="site-author-name" itemprop="name">神烦骑士</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/GoldenCorn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GoldenCorn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://goldencorn.github.io/2021/06/11/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E2%80%94%E2%80%94-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic.imgdb.cn/item/60b8adc28355f7f71805a59b.jpg">
      <meta itemprop="name" content="神烦骑士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神烦骑士的秘密基地">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode刷题记录 —— 树
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-11 21:51:20" itemprop="dateCreated datePublished" datetime="2021-06-11T21:51:20+08:00">2021-06-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-25 15:00:54" itemprop="dateModified" datetime="2021-06-25T15:00:54+08:00">2021-06-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tree/" itemprop="url" rel="index"><span itemprop="name">Tree</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/06/11/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E2%80%94%E2%80%94-%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/06/11/LeetCode刷题记录-——-树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>无语了，刷过的题忘得好快，包括解法全部忘光光。稍微记录一下。   </p>
<h5 id="2021-6-11"><a href="#2021-6-11" class="headerlink" title="2021.6.11"></a>2021.6.11</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  124    二叉树中的最大路径和    难度：Hard</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>   </p>
<p><strong>思路：</strong></p>
<p>利用二叉树的后序遍历计算不同子树的路径和，即左节点的值加上右节点的值加上该节点的值。每次计算都比较一次最大值，最后得到的最大值即为最大路径和。   </p>
<p><strong>细节：</strong></p>
<ol>
<li>递归的基线条件：<code>root == None</code>，说明该节点不存在，返回0；</li>
<li>递归计算左右子节点的最大贡献值，只有在贡献值大于0时，才选取对应子节点，否则舍弃；</li>
<li>当前节点所在子树的最大路径和取决于当前节点的值+左子节点的值+右子节点的值；</li>
<li>由于是求路径和，自底向上看的话，一个节点只能选取左子节点或者右子节点，因此递归的返回值应为当前节点的值+max(左子节点的值，右子节点的值)；至于左子节点-&gt;当前节点-&gt;右子节点的情况已经通过第3点的算式计算了；</li>
<li>时间复杂度：O(n)，遍历了一遍二叉树；</li>
<li>空间复杂度：O(n)，取决于递归调用栈，一般来说是O(h)，但最坏情况下是O(n)。   </li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode124/LeetCode124.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode124/LeetCode124.py">Python</a>   </p>
</li>
</ul>
<hr>
<h5 id="2021-6-12"><a href="#2021-6-12" class="headerlink" title="2021.6.12"></a>2021.6.12</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  105    从前序与中序遍历序列构造二叉树    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<p><strong>思路：</strong></p>
<p>由于前序遍历的顺序是【根节点-&gt;左子树-&gt;右子树】，而中序遍历的顺序是【左子树-&gt;根节点-&gt;右子树】，所以根据二者的数组可以推得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder &#x3D; [root, [subtree_left], [subtree_right]]</span><br><span class="line">inorder &#x3D; [[subtree_left], root, [subtree_right]]</span><br></pre></td></tr></table></figure>

<p>根据前序遍历数组中根节点的值，可以在中序遍历数组中定位到根节点的索引，从而分别计算出左子树和右子树的节点数量。再分别对前序遍历数组的左子树和右子树递归地调用这个过程，即可遍历整个二叉树，从而构造出这个二叉树。</p>
<p><strong>细节：</strong></p>
<ol>
<li><p>由上述分析可知，递归过程中需要多次在中序遍历数组中查找子树根节点的位置，如果每次都通过遍历数组来查找，时间复杂度较高。因此考虑将数组存储到哈希表来帮助快速定位，键表示节点的值，值表示节点在数组中的索引。</p>
</li>
<li><p>递归过程需要四个指针：<code>preLeft</code>、<code>preRight</code>、<code>inLeft</code>、<code>inRight</code>；分别代表两个数组的左边界和右边界；</p>
</li>
<li><p>递归的基线条件：<code>(preLeft &gt; preRight || inLeft &gt; inRight)</code>；</p>
</li>
<li><p>左子树的节点数量：<code>subtree_left = inRoot - inLeft</code>；</p>
</li>
<li><p>根据前序遍历数组构造左右子树时，左子树的边界可概括为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;preorder中，根节点索引+1...根节点索引+1+左子树的节点数量-1</span><br><span class="line">[preLeft + 1...preLeft + subtree_left]</span><br><span class="line">&#x2F;&#x2F;inorder中，起始位置索引...根节点索引-1</span><br><span class="line">[inLeft...inRoot - 1]</span><br></pre></td></tr></table></figure>

<p>右子树的边界可概括为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;preorder中，根节点索引+1+左子树的节点数量...结束位置索引</span><br><span class="line">[preLeft + 1 + subtree_left...preRight]</span><br><span class="line">&#x2F;&#x2F;inorder中，根节点索引+1...结束位置索引</span><br><span class="line">[inRoot + 1...inRight]</span><br></pre></td></tr></table></figure></li>
<li><p>递归的返回值为每个子树的根节点；</p>
</li>
<li><p>时间复杂度：O(n)，遍历了一遍二叉树；</p>
</li>
<li><p>空间复杂度：O(n)，返回的答案需要O(n)空间，存储数组到哈希表需要O(n)空间，以及递归时栈空间O(h)，h是树的高度。</p>
</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode105/LeetCode105.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode105/LeetCode105.py">Python</a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  99    恢复二叉搜索树    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></p>
<p><strong>思路：</strong></p>
<p>只需要找到错误的两个节点，将它们交换即可。</p>
<p>根据搜索二叉树左子节点的值&lt;根节点的值&lt;右子节点的值的特性，中序遍历后得到的数组必然是递增的，因此出现第一个节点（x）的值大于下一个节点（x+1）的值时，x节点就是要找的第一个错误节点，出现第二个节点（y-1）大于下一个节点（y）时，y节点就是要找的第二个错误节点，交换它们的值就可以修复二叉搜索树。</p>
<p><strong>细节：</strong></p>
<ol>
<li>需要一个节点指针<code>preNode</code>记录前一个节点，初始值为最小整数；</li>
<li><code>firstNode</code>节点记录第一个错误节点，<code>secondNode</code>记录第二个错误节点，初始值都为null；</li>
<li>中序遍历递归的基线条件：<code>root == null</code>；</li>
<li>当<code>firstNode == null</code>时，如果出现当前节点的值小于上一个节点<code>preNode</code>的值，则将<code>preNode</code>指针赋给<code>firstNode</code>；</li>
<li>当<code>firstNode != null</code>时，如果出现当前节点的值小于上一个节点<code>preNode</code>的值，意味着当前节点就是第二个错误节点，将<code>root</code>指针赋给<code>secondNode</code>；</li>
<li>记得将当前节点指针<code>root</code>赋给<code>preNode</code>。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode99/LeetCode99.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode99/LeetCode99.py">Python</a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-13"><a href="#2021-6-13" class="headerlink" title="2021.6.13"></a>2021.6.13</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  剑指 Offer 26    树的子结构    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></p>
<p><strong>思路：</strong></p>
<p>判断一棵树B是否是另一棵树A的子结构，只需要在树A中搜索是否包含树B的根节点，然后对于这个根节点，判断该子树的左右子节点在树A和树B中是否一致即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>遍历树A搜索树B的根节点时，采用前序遍历方法逐个比较；</li>
<li>前序遍历的基线条件：树A当前根节点为空或者树B当前根节点为空，不符合条件，返回false；</li>
<li>需要辅助函数来判断树B的结构和树A的子结构是否一致，使用递归来判断，也算一个前序遍历；</li>
<li>辅助函数的递归基线条件：<code>B == null</code>，树B的当前子节点为空，说明已经将树B遍历完都没有返回false，因此树B是树A的子结构，返回true；<code>A == null || A.val != B.val</code>，树A当前子节点为空但树B子节点不为空，或者子节点的值不相同，因此它们结构不一致，返回false；</li>
<li>时间复杂度：O(mn)，其中m和n分别为树A和树B的节点数，先前序遍历树A占用O(m)，后使用辅助函数前序遍历树B占O(n)；</li>
<li>空间复杂度：O(m)，最坏情况下，即树A退化为链表，且遍历至树A的叶子节点，此时递归调用栈深度为m。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer26/%E5%89%91%E6%8C%87Offer26.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer26/%E5%89%91%E6%8C%87Offer26.py">Python</a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-14"><a href="#2021-6-14" class="headerlink" title="2021.6.14"></a>2021.6.14</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  226    翻转二叉树    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></p>
<p><strong>思路：</strong></p>
<p>无语了，一个贼拉简单的题被我想复杂了。开始甚至都想到什么反向后序遍历了（其实也没用），结果只需要遍历并记录一下左右子树，然后交换二者位置即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：<code>root == null</code>，返回空值；</li>
<li>递归调用左子节点保存到<code>TreeNode left</code>，右子节点保存到<code>TreeNode right</code>；</li>
<li>交换左右子节点位置：<code>root.left = left; root.right = right;</code>；</li>
<li>返回值为<code>root</code>；</li>
<li>时间复杂度：O(n)，需要遍历树的每一个节点；</li>
<li>空间复杂度：O(n)，最坏情况下，即树退化成链表，递归调用栈需要占用n的空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode226/LeetCode226.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode226/LeetCode226.py">Python</a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  101    对称二叉树    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></p>
<p><strong>思路：</strong></p>
<p>可采用双指针同步移动来判断左右子树是否完全对称，指针p向左子树遍历时，指针q向右子树遍历，递归地判断二者指向的节点值是否相等。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：<code>p == null &amp;&amp; q == null</code>，说明遍历到叶子节点为止，左右子树是完全对称的，因此返回true；接着<code>p == null || q == null</code>，说明其中一个指针不为空的情况下，另一个指针为空，说明左右子树不对称，返回false；</li>
<li>直接在返回语句中判断二者指向的节点的值是否相等，以及进行向下遍历的操作；</li>
<li>时间复杂度：O(n)，将树的节点都遍历了一遍；</li>
<li>空间复杂度：O(n)，最糟情况下递归调用栈需要占用n的空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode101/LeetCode101.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode101/LeetCode101.py">Python</a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  剑指 Offer 32    从上到下打印二叉树    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></p>
<p><strong>思路：</strong></p>
<p>一层层打印二叉树即为二叉树的层序遍历，又称为二叉树的广度优先搜索（BFS），BFS常用队列的先入先出特性来实现。</p>
<p>只要按照从左到右的顺序将每一层的节点压入队列，然后保存节点的值并查找下一层子节点即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>使用while循环，循环的退出条件为：队列为空。说明二叉树已经遍历完毕。</li>
<li>由于需要以数组的形式打印，而数组的长度是不确定的，因此先使用一个列表缓存各节点的值。将队列中的第一个节点弹出，并将该节点的值保存到列表中；</li>
<li>如果该节点的左右子节点不为空，则分别将它们压入队列中；</li>
<li>将得到的列表转换为数组并返回；</li>
<li><strong>注意</strong>：用Python解题时，队列使用collections中的双端队列deque()，其popleft()方法可达到O(1)时间复杂度；列表list的pop(0)方法时间复杂度为 O(N)；</li>
<li>时间复杂度：O(n)，树的所有节点都被遍历了一遍；</li>
<li>空间复杂度：O(n)，使用了列表来缓存数据，占用n的空间；最坏情况下，当树为平衡二叉树时，最多有2/n个节点在队列中，因此使用O(n)大小的额外空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer32/%E5%89%91%E6%8C%87Offer32.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer32/%E5%89%91%E6%8C%87Offer32.py">Python</a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-16"><a href="#2021-6-16" class="headerlink" title="2021.6.16"></a>2021.6.16</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  102    二叉树的层序遍历    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<p><strong>思路：</strong></p>
<p>由于每一层的节点需要单独加入列表中打印，因此需要在将节点添加到列表前获取当前层数的节点数量，即当前队列中的节点数。然后使用for循环将那一层的节点一次性添加。</p>
<p><strong>细节：</strong></p>
<ol>
<li>while循环退出条件：队列为空；</li>
<li>弹出节点前，获取当前队列的元素个数，元素个数即代表该层有几个节点，根据节点数for循环遍历，并添加下一层的节点到队列中；</li>
<li>将该层遍历后得到的列表添加到输出列表中；</li>
<li>时间复杂度：O(n)，遍历了一遍所有节点；</li>
<li>空间复杂度：O(n)，最坏情况下队列中的节点数为2/n，因此占用O(n)大小的额外空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode102/LeetCode102.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode102/LeetCode102.py">Python</a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  剑指 Offer 32    从上到下打印二叉树 III    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></p>
<p><strong>思路：</strong></p>
<p>在层序遍历逐层打印的基础上，根据当前层数决定输出节点值到链表中时是从左往右还是从右往左。</p>
<p><strong>细节：</strong></p>
<ol>
<li>while循环退出条件：队列为空；</li>
<li>记录当前层数，若当前为奇数层，将节点值添加到链表尾部；若为偶数层，将节点值添加到链表首部；</li>
<li>时间复杂度：O(n)，遍历了一遍二叉树；</li>
<li>空间复杂度：O(n)，最坏情况下队列中有2/n个元素。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer32/%E5%89%91%E6%8C%87Offer32-3.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer32/%E5%89%91%E6%8C%87Offer32-3.py">Python</a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-17"><a href="#2021-6-17" class="headerlink" title="2021.6.17"></a>2021.6.17</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  113    路径总和 II    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></p>
<p><strong>思路：</strong></p>
<p>由于是求从根节点开始到叶子节点的路径，因此使用深度优先搜索（DFS），个人感觉也能算回溯算法。在前序遍历位置将节点值入队列，后序遍历位置表示条件不满足，因此又将最后入队的节点值弹出队列。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空；</li>
<li>前序遍历位置，当前节点值入队，将目标值减去当前节点值；</li>
<li>判断当前节点是否是叶子节点，即其左右子节点都为空，并判断当前目标值是否为0，若满足条件，则表示路径和即为目标值，队列中的节点值即为满足条件的路径。将当前队列添加到结果链表中；</li>
<li>不满足条件则继续遍历左右子节点；</li>
<li>后序遍历位置表示已经遍历完毕，且不满足条件，因此弹出最后一个入队的节点值，回溯到上一个节点继续遍历；</li>
<li>时间复杂度：O(nlogn)，需要遍历每一个节点（O(n)），并且递归的过程中，需要将一条路径包含的节点值打印（O(logn)），因此总的时间复杂度为O(nlogn)；</li>
<li>空间复杂度：O(n)，最坏情况下，递归调用栈占用O(n)的额外空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode113/LeetCode113.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode113/LeetCode113.py">Python</a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-18"><a href="#2021-6-18" class="headerlink" title="2021.6.18"></a>2021.6.18</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  剑指 Offer 54    二叉搜索树的第k大节点    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></p>
<p><strong>思路：</strong></p>
<p>最开始是想到使用中序遍历将搜索二叉树的节点值都保存到数组列表里，然后根据k的值计算索引，从而在列表中查到需要的节点值。但是后来看解答发现可以使用倒序的中序遍历，即先遍历右子节点然后根节点然后左子节点，这样可以不需要将树全部遍历一遍，只要在第k大的值出现时退出递归即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空；</li>
<li>使用倒序的中序遍历，先判断当前k值是否为0，为0则表示上一次遍历已经找到了第k大的值，因此退出递归；k值自减1；在k自减1之后判断k此时是否为0，为0则表示当前节点的值即为第k大的值，使用一个全局变量记录当前值；</li>
<li>注意k值也必须是全局变量；</li>
<li>时间复杂度：O(n)，由于是中序遍历，最坏情况下，树退化成链表，无论k值多大，递归深度都是n；</li>
<li>空间复杂度：O(n)，最坏情况同上；</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer54/%E5%89%91%E6%8C%87Offer54.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer54/%E5%89%91%E6%8C%87Offer54.py">Python</a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  104    二叉树的最大深度    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<p><strong>思路：</strong></p>
<p>自己写的时候是用了个局部变量记录当前的深度，然后还判断了当前节点是否是叶子节点，最后还比较了当前叶子节点的深度值和全局的最大深度值，取较大的那个作为答案；没想到看大佬写的获取深度就俩行：<code>int left = traverse(root.left);    int right = traverse(root.right);</code>，分别获取左右子树的深度，看来还是我的递归理解不到位啊。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空；</li>
<li>分别获取左右子树深度，返回值为当前节点的左右子树中更大的值，再加上1才表示当前节点的深度；</li>
<li>时间复杂度：O(n)，需要遍历所有节点；</li>
<li>空间复杂度：O(n)，最坏情况下递归栈深度占用O(n)额外空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode104/LeetCode104.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode104/LeetCode104.py">Python</a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-19"><a href="#2021-6-19" class="headerlink" title="2021.6.19"></a>2021.6.19</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  110    平衡二叉树    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></p>
<p><strong>思路：</strong></p>
<p>我自己的解法是先使用后序遍历自底向上地计算左右子树的深度，然后在过程中不断比较左右子树的深度差，如果深度差的绝对值大于1，则将答案（全局变量）记录为False，否则继续遍历，答案的初始值是True。然后官方的解法是省去了这个记录答案的变量，如果左右子树深度差绝对值大于1或者当前节点的左右子树深度有任一个是-1（说明已经深度差大于1），则返回-1；然后主方法的返回值直接判断递归方法返回值是否大于等于0即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空；</li>
<li>如果左右子树深度差绝对值大于1，或者当前节点的左右子树深度有任一个是-1，返回-1；</li>
<li>递归的返回值为当前节点的深度：左右子树深度中较大的那个 + 1；</li>
<li>返回并判断递归结果是否大于等于0；</li>
<li>时间复杂度：O(n)，最坏情况下树退化成链表；</li>
<li>空间复杂度：O(n)，同上</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode110/LeetCode110.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode110/LeetCode110.py">Python</a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-20"><a href="#2021-6-20" class="headerlink" title="2021.6.20"></a>2021.6.20</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  236    二叉树的最近公共祖先    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p>
<p><strong>思路：</strong></p>
<p>可以自底向上地，即后序遍历二叉树，搜索给定的两个节点。如果当前节点的左子树为空，说明左子树中不包含给定的两个节点，因此返回当前节点的右子树搜索结果；同理，若当前节点的右子树为空，返回左子树搜索结果；如果当前节点的左右子树都不为空，说明给定的俩节点分别位于当前节点的左右子树上，因此当前节点就是它俩的最近公共祖先。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空，或当前节点为给定节点的其中一个，返回当前节点；</li>
<li>当前节点的左子树为空，返回右子树搜索结果；当前节点的右子树为空，返回左子树搜索结果；</li>
<li>二者都不为空，返回当前节点；</li>
<li>时间复杂度：O(n)，所有节点都会被遍历一次；</li>
<li>空间复杂度：O(n)，最坏情况下二叉树退化为链表，递归调用栈占用O(n)的空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode236/LeetCode236.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode236/LeetCode236.py">Python</a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  235    二叉搜索树的最近公共祖先    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></p>
<p><strong>思路：</strong></p>
<p>原理和上一题差不多，不过可以利用二叉搜索树“左子树所有节点的值都小于根节点的值小于右子树所有节点的值”的特性，从根节点开始遍历，如果当前节点的值分别与给定节点的值相减后的乘积小于等于0，则说明两个给定节点分别位于当前节点的两侧，因此返回当前节点；否则比较当前节点和任一节点的值，判断两个给定节点位于左子树还是右子树，然后相应地进行遍历。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空，或当前节点的值分别与给定节点的值相减后的乘积小于等于0；</li>
<li>如果当前节点的值大于给定节点的值，则往左子树遍历；否则往右子树遍历；</li>
<li>时间复杂度：O(n)，最坏情况下，二叉树退化成链表；</li>
<li>空间复杂度：O(n)，同上。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode235/LeetCode235.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode235/LeetCode235.py">Python</a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  297    二叉树的序列化与反序列化    难度：Hard</p>
<p><strong>题目描述：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></p>
<p><strong>思路：</strong></p>
<p>个人感觉这题挺变态的，反正我自己是写不出来。过程其实还算好理解，就是很多细节容易把人逼疯。</p>
<p>方法有很多种，我尝试的是直接前序遍历二叉树，遇到空节点的时候标记为“#”，否则继续遍历并序列化节点；反序列化时需要先将字符串中的逗号去掉，然后转换成链表，从左到右遍历链表来重构二叉树。</p>
<p><strong>细节：</strong></p>
<ol>
<li>序列化过程中字符串的构建需要特别注意，左右子树的遍历结果以及特殊符号都要做加法；</li>
<li>反序列化时，字符串去逗号之后是变成一个字符串数组；转换成链表可以直接<code>List&lt;String&gt; tree = new LinkedList&lt;String&gt;(Arrays.asList(nodes));</code>；</li>
<li>链表的遍历要边访问边删除；</li>
<li>时间复杂度：O(n)，在两个函数中都是需要遍历一次二叉树；</li>
<li>空间复杂度：O(n)，递归调用栈最坏情况下占用O(n)空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode297/LeetCode297.java">Java</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode297/LeetCode297.py">Python</a></p>
</li>
</ul>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/10/Blog%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" rel="prev" title="Blog搭建过程记录">
                  <i class="fa fa-chevron-left"></i> Blog搭建过程记录
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/21/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E2%80%94%E2%80%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="next" title="LeetCode刷题记录 —— 动态规划">
                  LeetCode刷题记录 —— 动态规划 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">神烦骑士</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"default","js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.11.0/dist/mermaid.min.js","integrity":"sha256-sVAx+v/Q7v0Q2xm5vN7h5ccSna6gaLREhG9sF8pKT6I="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"goldencorn","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
