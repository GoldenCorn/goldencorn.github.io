<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="神烦骑士">
    
    <title>
        
            LeetCode刷题记录 |
        
        神烦骑士的秘密基地
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"goldencorn.github.io","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#009966","avatar":"https://pic.imgdb.cn/item/60b8adc28355f7f71805a59b.jpg","favicon":"/images/logo.svg","article_img_align":"center","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"https://pic.imgdb.cn/item/60b8aca98355f7f718f71a0b.jpg","description":"Stay Hungry, Stay Wild."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                神烦骑士的秘密基地
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode刷题记录</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://pic.imgdb.cn/item/60b8adc28355f7f71805a59b.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">神烦骑士</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-06-11 21:51:20
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Notes/">Notes</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>3.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>13 Mins</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>无语了，刷过的题忘得好快，包括解法全部忘光光。稍微记录一下。   </p>
<h5 id="2021-6-11"><a href="#2021-6-11" class="headerlink" title="2021.6.11"></a>2021.6.11</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  124    二叉树中的最大路径和    难度：Hard</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" >124. 二叉树中的最大路径和<i class="fas fa-external-link-alt"></i></a>   </p>
<p><strong>思路：</strong></p>
<p>利用二叉树的后序遍历计算不同子树的路径和，即左节点的值加上右节点的值加上该节点的值。每次计算都比较一次最大值，最后得到的最大值即为最大路径和。   </p>
<p><strong>细节：</strong></p>
<ol>
<li>递归的基线条件：<code>root == None</code>，说明该节点不存在，返回0；</li>
<li>递归计算左右子节点的最大贡献值，只有在贡献值大于0时，才选取对应子节点，否则舍弃；</li>
<li>当前节点所在子树的最大路径和取决于当前节点的值+左子节点的值+右子节点的值；</li>
<li>由于是求路径和，自底向上看的话，一个节点只能选取左子节点或者右子节点，因此递归的返回值应为当前节点的值+max(左子节点的值，右子节点的值)；至于左子节点-&gt;当前节点-&gt;右子节点的情况已经通过第3点的算式计算了；</li>
<li>时间复杂度：O(n)，遍历了一遍二叉树；</li>
<li>空间复杂度：O(n)，取决于递归调用栈，一般来说是O(h)，但最坏情况下是O(n)。   </li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode124/LeetCode124.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode124/LeetCode124.py" >Python<i class="fas fa-external-link-alt"></i></a>   </p>
</li>
</ul>
<hr>
<h5 id="2021-6-12"><a href="#2021-6-12" class="headerlink" title="2021.6.12"></a>2021.6.12</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  105    从前序与中序遍历序列构造二叉树    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >105. 从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>由于前序遍历的顺序是【根节点-&gt;左子树-&gt;右子树】，而中序遍历的顺序是【左子树-&gt;根节点-&gt;右子树】，所以根据二者的数组可以推得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder &#x3D; [root, [subtree_left], [subtree_right]]</span><br><span class="line">inorder &#x3D; [[subtree_left], root, [subtree_right]]</span><br></pre></td></tr></table></figure>

<p>根据前序遍历数组中根节点的值，可以在中序遍历数组中定位到根节点的索引，从而分别计算出左子树和右子树的节点数量。再分别对前序遍历数组的左子树和右子树递归地调用这个过程，即可遍历整个二叉树，从而构造出这个二叉树。</p>
<p><strong>细节：</strong></p>
<ol>
<li><p>由上述分析可知，递归过程中需要多次在中序遍历数组中查找子树根节点的位置，如果每次都通过遍历数组来查找，时间复杂度较高。因此考虑将数组存储到哈希表来帮助快速定位，键表示节点的值，值表示节点在数组中的索引。</p>
</li>
<li><p>递归过程需要四个指针：<code>preLeft</code>、<code>preRight</code>、<code>inLeft</code>、<code>inRight</code>；分别代表两个数组的左边界和右边界；</p>
</li>
<li><p>递归的基线条件：<code>(preLeft &gt; preRight || inLeft &gt; inRight)</code>；</p>
</li>
<li><p>左子树的节点数量：<code>subtree_left = inRoot - inLeft</code>；</p>
</li>
<li><p>根据前序遍历数组构造左右子树时，左子树的边界可概括为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;preorder中，根节点索引+1...根节点索引+1+左子树的节点数量-1</span><br><span class="line">[preLeft + 1...preLeft + subtree_left]</span><br><span class="line">&#x2F;&#x2F;inorder中，起始位置索引...根节点索引-1</span><br><span class="line">[inLeft...inRoot - 1]</span><br></pre></td></tr></table></figure>

<p>右子树的边界可概括为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;preorder中，根节点索引+1+左子树的节点数量...结束位置索引</span><br><span class="line">[preLeft + 1 + subtree_left...preRight]</span><br><span class="line">&#x2F;&#x2F;inorder中，根节点索引+1...结束位置索引</span><br><span class="line">[inRoot + 1...inRight]</span><br></pre></td></tr></table></figure></li>
<li><p>递归的返回值为每个子树的根节点；</p>
</li>
<li><p>时间复杂度：O(n)，遍历了一遍二叉树；</p>
</li>
<li><p>空间复杂度：O(n)，返回的答案需要O(n)空间，存储数组到哈希表需要O(n)空间，以及递归时栈空间O(h)，h是树的高度。</p>
</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode105/LeetCode105.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode105/LeetCode105.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  99    恢复二叉搜索树    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-binary-search-tree/" >99. 恢复二叉搜索树<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>只需要找到错误的两个节点，将它们交换即可。</p>
<p>根据搜索二叉树左子节点的值&lt;根节点的值&lt;右子节点的值的特性，中序遍历后得到的数组必然是递增的，因此出现第一个节点（x）的值大于下一个节点（x+1）的值时，x节点就是要找的第一个错误节点，出现第二个节点（y-1）大于下一个节点（y）时，y节点就是要找的第二个错误节点，交换它们的值就可以修复二叉搜索树。</p>
<p><strong>细节：</strong></p>
<ol>
<li>需要一个节点指针<code>preNode</code>记录前一个节点，初始值为最小整数；</li>
<li><code>firstNode</code>节点记录第一个错误节点，<code>secondNode</code>记录第二个错误节点，初始值都为null；</li>
<li>中序遍历递归的基线条件：<code>root == null</code>；</li>
<li>当<code>firstNode == null</code>时，如果出现当前节点的值小于上一个节点<code>preNode</code>的值，则将<code>preNode</code>指针赋给<code>firstNode</code>；</li>
<li>当<code>firstNode != null</code>时，如果出现当前节点的值小于上一个节点<code>preNode</code>的值，意味着当前节点就是第二个错误节点，将<code>root</code>指针赋给<code>secondNode</code>；</li>
<li>记得将当前节点指针<code>root</code>赋给<code>preNode</code>。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode99/LeetCode99.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode99/LeetCode99.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-13"><a href="#2021-6-13" class="headerlink" title="2021.6.13"></a>2021.6.13</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  剑指 Offer 26    树的子结构    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" >剑指 Offer 26. 树的子结构<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>判断一棵树B是否是另一棵树A的子结构，只需要在树A中搜索是否包含树B的根节点，然后对于这个根节点，判断该子树的左右子节点在树A和树B中是否一致即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>遍历树A搜索树B的根节点时，采用前序遍历方法逐个比较；</li>
<li>前序遍历的基线条件：树A当前根节点为空或者树B当前根节点为空，不符合条件，返回false；</li>
<li>需要辅助函数来判断树B的结构和树A的子结构是否一致，使用递归来判断，也算一个前序遍历；</li>
<li>辅助函数的递归基线条件：<code>B == null</code>，树B的当前子节点为空，说明已经将树B遍历完都没有返回false，因此树B是树A的子结构，返回true；<code>A == null || A.val != B.val</code>，树A当前子节点为空但树B子节点不为空，或者子节点的值不相同，因此它们结构不一致，返回false；</li>
<li>时间复杂度：O(mn)，其中m和n分别为树A和树B的节点数，先前序遍历树A占用O(m)，后使用辅助函数前序遍历树B占O(n)；</li>
<li>空间复杂度：O(m)，最坏情况下，即树A退化为链表，且遍历至树A的叶子节点，此时递归调用栈深度为m。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer26/%E5%89%91%E6%8C%87Offer26.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer26/%E5%89%91%E6%8C%87Offer26.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-14"><a href="#2021-6-14" class="headerlink" title="2021.6.14"></a>2021.6.14</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  226    翻转二叉树    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/" >226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>无语了，一个贼拉简单的题被我想复杂了。开始甚至都想到什么反向后序遍历了（其实也没用），结果只需要遍历并记录一下左右子树，然后交换二者位置即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：<code>root == null</code>，返回空值；</li>
<li>递归调用左子节点保存到<code>TreeNode left</code>，右子节点保存到<code>TreeNode right</code>；</li>
<li>交换左右子节点位置：<code>root.left = left; root.right = right;</code>；</li>
<li>返回值为<code>root</code>；</li>
<li>时间复杂度：O(n)，需要遍历树的每一个节点；</li>
<li>空间复杂度：O(n)，最坏情况下，即树退化成链表，递归调用栈需要占用n的空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode226/LeetCode226.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode226/LeetCode226.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  101    对称二叉树    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/" >101. 对称二叉树<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>可采用双指针同步移动来判断左右子树是否完全对称，指针p向左子树遍历时，指针q向右子树遍历，递归地判断二者指向的节点值是否相等。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：<code>p == null &amp;&amp; q == null</code>，说明遍历到叶子节点为止，左右子树是完全对称的，因此返回true；接着<code>p == null || q == null</code>，说明其中一个指针不为空的情况下，另一个指针为空，说明左右子树不对称，返回false；</li>
<li>直接在返回语句中判断二者指向的节点的值是否相等，以及进行向下遍历的操作；</li>
<li>时间复杂度：O(n)，将树的节点都遍历了一遍；</li>
<li>空间复杂度：O(n)，最糟情况下递归调用栈需要占用n的空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode101/LeetCode101.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode101/LeetCode101.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  剑指 Offer 32    从上到下打印二叉树    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" >剑指 Offer 32 - I. 从上到下打印二叉树<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>一层层打印二叉树即为二叉树的层序遍历，又称为二叉树的广度优先搜索（BFS），BFS常用队列的先入先出特性来实现。</p>
<p>只要按照从左到右的顺序将每一层的节点压入队列，然后保存节点的值并查找下一层子节点即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>使用while循环，循环的退出条件为：队列为空。说明二叉树已经遍历完毕。</li>
<li>由于需要以数组的形式打印，而数组的长度是不确定的，因此先使用一个列表缓存各节点的值。将队列中的第一个节点弹出，并将该节点的值保存到列表中；</li>
<li>如果该节点的左右子节点不为空，则分别将它们压入队列中；</li>
<li>将得到的列表转换为数组并返回；</li>
<li><strong>注意</strong>：用Python解题时，队列使用collections中的双端队列deque()，其popleft()方法可达到O(1)时间复杂度；列表list的pop(0)方法时间复杂度为 O(N)；</li>
<li>时间复杂度：O(n)，树的所有节点都被遍历了一遍；</li>
<li>空间复杂度：O(n)，使用了列表来缓存数据，占用n的空间；最坏情况下，当树为平衡二叉树时，最多有2/n个节点在队列中，因此使用O(n)大小的额外空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer32/%E5%89%91%E6%8C%87Offer32.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer32/%E5%89%91%E6%8C%87Offer32.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-16"><a href="#2021-6-16" class="headerlink" title="2021.6.16"></a>2021.6.16</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  102    二叉树的层序遍历    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>由于每一层的节点需要单独加入列表中打印，因此需要在将节点添加到列表前获取当前层数的节点数量，即当前队列中的节点数。然后使用for循环将那一层的节点一次性添加。</p>
<p><strong>细节：</strong></p>
<ol>
<li>while循环退出条件：队列为空；</li>
<li>弹出节点前，获取当前队列的元素个数，元素个数即代表该层有几个节点，根据节点数for循环遍历，并添加下一层的节点到队列中；</li>
<li>将该层遍历后得到的列表添加到输出列表中；</li>
<li>时间复杂度：O(n)，遍历了一遍所有节点；</li>
<li>空间复杂度：O(n)，最坏情况下队列中的节点数为2/n，因此占用O(n)大小的额外空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode102/LeetCode102.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode102/LeetCode102.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  剑指 Offer 32    从上到下打印二叉树 III    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" >剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>在层序遍历逐层打印的基础上，根据当前层数决定输出节点值到链表中时是从左往右还是从右往左。</p>
<p><strong>细节：</strong></p>
<ol>
<li>while循环退出条件：队列为空；</li>
<li>记录当前层数，若当前为奇数层，将节点值添加到链表尾部；若为偶数层，将节点值添加到链表首部；</li>
<li>时间复杂度：O(n)，遍历了一遍二叉树；</li>
<li>空间复杂度：O(n)，最坏情况下队列中有2/n个元素。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer32/%E5%89%91%E6%8C%87Offer32-3.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer32/%E5%89%91%E6%8C%87Offer32-3.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-17"><a href="#2021-6-17" class="headerlink" title="2021.6.17"></a>2021.6.17</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  113    路径总和 II    难度：Medium</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/" >113. 路径总和 II<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>由于是求从根节点开始到叶子节点的路径，因此使用深度优先搜索（DFS），个人感觉也能算回溯算法。在前序遍历位置将节点值入队列，后序遍历位置表示条件不满足，因此又将最后入队的节点值弹出队列。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空；</li>
<li>前序遍历位置，当前节点值入队，将目标值减去当前节点值；</li>
<li>判断当前节点是否是叶子节点，即其左右子节点都为空，并判断当前目标值是否为0，若满足条件，则表示路径和即为目标值，队列中的节点值即为满足条件的路径。将当前队列添加到结果链表中；</li>
<li>不满足条件则继续遍历左右子节点；</li>
<li>后序遍历位置表示已经遍历完毕，且不满足条件，因此弹出最后一个入队的节点值，回溯到上一个节点继续遍历；</li>
<li>时间复杂度：O(nlogn)，需要遍历每一个节点（O(n)），并且递归的过程中，需要将一条路径包含的节点值打印（O(logn)），因此总的时间复杂度为O(nlogn)；</li>
<li>空间复杂度：O(n)，最坏情况下，递归调用栈占用O(n)的额外空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode113/LeetCode113.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode113/LeetCode113.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<h5 id="2021-6-18"><a href="#2021-6-18" class="headerlink" title="2021.6.18"></a>2021.6.18</h5><hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  剑指 Offer 54    二叉搜索树的第k大节点    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" >剑指 Offer 54. 二叉搜索树的第k大节点<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>最开始是想到使用中序遍历将搜索二叉树的节点值都保存到数组列表里，然后根据k的值计算索引，从而在列表中查到需要的节点值。但是后来看解答发现可以使用倒序的中序遍历，即先遍历右子节点然后根节点然后左子节点，这样可以不需要将树全部遍历一遍，只要在第k大的值出现时退出递归即可。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空；</li>
<li>使用倒序的中序遍历，先判断当前k值是否为0，为0则表示上一次遍历已经找到了第k大的值，因此退出递归；k值自减1；在k自减1之后判断k此时是否为0，为0则表示当前节点的值即为第k大的值，使用一个全局变量记录当前值；</li>
<li>注意k值也必须是全局变量；</li>
<li>时间复杂度：O(n)，由于是中序遍历，最坏情况下，树退化成链表，无论k值多大，递归深度都是n；</li>
<li>空间复杂度：O(n)，最坏情况同上；</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer54/%E5%89%91%E6%8C%87Offer54.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/%E5%89%91%E6%8C%87Offer54/%E5%89%91%E6%8C%87Offer54.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  104    二叉树的最大深度    难度：Simple</p>
<p><strong>题目描述：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" >104. 二叉树的最大深度<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>思路：</strong></p>
<p>自己写的时候是用了个局部变量记录当前的深度，然后还判断了当前节点是否是叶子节点，最后还比较了当前叶子节点的深度值和全局的最大深度值，取较大的那个作为答案；没想到看大佬写的获取深度就俩行：<code>int left = traverse(root.left);    int right = traverse(root.right);</code>，分别获取左右子树的深度，看来还是我的递归理解不到位啊。</p>
<p><strong>细节：</strong></p>
<ol>
<li>递归基线条件：当前节点为空；</li>
<li>分别获取左右子树深度，返回值为当前节点的左右子树中更大的值，再加上1才表示当前节点的深度；</li>
<li>时间复杂度：O(n)，需要遍历所有节点；</li>
<li>空间复杂度：O(n)，最坏情况下递归栈深度占用O(n)额外空间。</li>
</ol>
<p><strong>题解：</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode104/LeetCode104.java" >Java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/starkn1ght/algorithms/blob/master/LeetCode104/LeetCode104.py" >Python<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<hr>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：LeetCode刷题记录</li>
        <li>Post author：神烦骑士</li>
        <li>Create time：2021-06-11 21:51:20</li>
        <li>
            Post link：https://goldencorn.github.io/2021/06/11/LeetCode刷题记录/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/06/10/Blog%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Blog搭建过程记录</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">神烦骑士</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-11"><span class="nav-number">1.</span> <span class="nav-text">2021.6.11</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-12"><span class="nav-number">2.</span> <span class="nav-text">2021.6.12</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-13"><span class="nav-number">3.</span> <span class="nav-text">2021.6.13</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-14"><span class="nav-number">4.</span> <span class="nav-text">2021.6.14</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-16"><span class="nav-number">5.</span> <span class="nav-text">2021.6.16</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-17"><span class="nav-number">6.</span> <span class="nav-text">2021.6.17</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2021-6-18"><span class="nav-number">7.</span> <span class="nav-text">2021.6.18</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script>


    <script src="/js/local-search.js"></script>



    <script src="/js/code-copy.js"></script>



    <script src="/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script>
    
</div>


    <script src="/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
